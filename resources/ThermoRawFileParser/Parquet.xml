<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Parquet</name>
    </assembly>
    <members>
        <member name="M:Snappy.Sharp.SnappyDecompressor.DecompressTagSlow(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32)">
            NOTE: from Java version, need to determine if true in .Net as well.
            This is a second copy of the inner loop of decompressTags used when near the end
            of the input. The key difference is the reading of the trailer bytes.  The fast
            code does a blind read of the next 4 bytes as an int, and this code assembles
            the int byte-by-byte to assure that the array is not over run.  The reason this
            code path is separate is the if condition to choose between these two seemingly
            small differences costs like 10-20% of the throughput.  I'm hoping in future
            versions of hot-spot this code can be integrated into the main loop but for now
            it is worth the extra maintenance pain to get the extra 10-20%.
        </member>
        <member name="M:Snappy.Sharp.SnappyDecompressor.IncrementalCopy(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
             Copy "len" bytes from "src" to "op", one byte at a time.  Used for
             handling COPY operations where the input and output regions may
             overlap.  For example, suppose:
             src    == "ab"
             op     == src + 2
             len    == 20
            
             After incrementalCopy, the result will have
             eleven copies of "ab"
             ababababababababababab
             Note that this does not match the semantics of either memcpy()
             or memmove().
        </member>
        <member name="M:Snappy.Sharp.SnappyStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Snappy.Sharp.SnappyStream"/> class.
            </summary>
            <param name="s">The stream.</param>
            <param name="mode">The compression mode.</param>
        </member>
        <member name="M:Snappy.Sharp.SnappyStream.#ctor(System.IO.Stream,System.IO.Compression.CompressionMode,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Snappy.Sharp.SnappyStream"/> class.
            </summary>
            <param name="s">The stream.</param>
            <param name="mode">The compression mode.</param>
            <param name="leaveOpen">If set to <c>true</c> leaves the stream open when complete.</param>
            <param name="checksum"><c>true</c> if checksums should be written to the stream </param>
        </member>
        <member name="P:Snappy.Sharp.SnappyStream.BaseStream">
            <summary>
            Provides access to the underlying (compressed) <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="M:Snappy.Sharp.SnappyStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This operation is not supported and always throws a <see cref="T:System.NotSupportedException" />.
            </summary>
            <exception cref="T:System.NotSupportedException">This operation is not supported on this stream.</exception>
        </member>
        <member name="M:Snappy.Sharp.SnappyStream.SetLength(System.Int64)">
            <summary>
            This operation is not supported and always throws a <see cref="T:System.NotSupportedException" />.
            </summary>
            <exception cref="T:System.NotSupportedException">This operation is not supported on this stream.</exception>
        </member>
        <member name="P:Snappy.Sharp.SnappyStream.Length">
            <summary>
            This property is not supported and always throws a <see cref="T:System.NotSupportedException" />.
            </summary>
            <exception cref="T:System.NotSupportedException">This property is not supported on this stream.</exception>
        </member>
        <member name="P:Snappy.Sharp.SnappyStream.Position">
            <summary>
            This property is not supported and always throws a <see cref="T:System.NotSupportedException" />.
            </summary>
            <exception cref="T:System.NotSupportedException">This property is not supported on this stream.</exception>
        </member>
        <member name="M:Snappy.Sharp.Utilities.UnalignedCopy64(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies 64 bits (8 bytes) from source array starting at sourceIndex into dest array starting at destIndex.
            </summary>
            <param name="source">The source array.</param>
            <param name="sourceIndex">Index to start copying.</param>
            <param name="dest">The destination array.</param>
            <param name="destIndex">Index to start writing.</param>
            <remarks>The name comes from the original Snappy C++ source. I don't think there is a good way to look at 
            things in an aligned manner in the .NET Framework.</remarks>
        </member>
        <member name="M:Snappy.Sharp.Utilities.GetFourBytes(System.Byte[],System.Int32)">
            <summary>>
             Reads 4 bytes from memory into a uint. Does not take host enianness into account.
             </summary>
        </member>
        <member name="M:Snappy.Sharp.Utilities.GetEightBytes(System.Byte[],System.Int32)">
            <summary>>
             Reads 8 bytes from memory into a uint. Does not take host enianness into account.
             </summary>
        </member>
        <member name="M:Thrift.Collections.TCollections.Equals(System.Collections.IEnumerable,System.Collections.IEnumerable)">
            <summary>
            This will return true if the two collections are value-wise the same.
            If the collection contains a collection, the collections will be compared using this method.
            </summary>
        </member>
        <member name="M:Thrift.Collections.TCollections.GetHashCode(System.Collections.IEnumerable)">
            <summary>
            This returns a hashcode based on the value of the enumerable.
            </summary>
        </member>
        <member name="M:Thrift.Protocol.TAbstractBase.Write(Thrift.Protocol.TProtocol)">
            
             Writes the objects out to the protocol
            
        </member>
        <member name="M:Thrift.Protocol.TBase.Read(Thrift.Protocol.TProtocol)">
            
             Reads the TObject from the given input protocol.
            
        </member>
        <member name="T:Thrift.Protocol.TBinaryProtocol.Factory">
            Factory
        </member>
        <member name="T:Thrift.Protocol.TCompactProtocol.Types">
            All of the on-wire type codes.
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.lastField_">
            Used to keep track of the last field for the current and previous structs,
            so we can do the delta stuff.
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.booleanField_">
            If we encounter a boolean field begin, save the TField here so it can
            have the value incorporated.
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.boolValue_">
            If we Read a field header, and it's a boolean field, save the boolean
            value here so that ReadBool can use it.
        </member>
        <member name="T:Thrift.Protocol.TCompactProtocol.Factory">
            Factory
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.byteDirectBuffer">
            Writes a byte without any possibility of all that field header nonsense.
            Used internally by other writing methods that know they need to Write a byte.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteByteDirect(System.Int32)">
            Writes a byte without any possibility of all that field header nonsense.
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.i32buf">
            Write an i32 as a varint. Results in 1-5 bytes on the wire.
            TODO: make a permanent buffer like WriteVarint64?
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteMessageBegin(Thrift.Protocol.TMessage)">
            Write a message header to the wire. Compact Protocol messages contain the
            protocol version so we can migrate forwards in the future if need be.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteStructBegin(Thrift.Protocol.TStruct)">
            Write a struct begin. This doesn't actually put anything on the wire. We
            use it as an opportunity to put special placeholder markers on the field
            stack so we can get the field id deltas correct.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteStructEnd">
            Write a struct end. This doesn't actually put anything on the wire. We use
            this as an opportunity to pop the last field from the current struct off
            of the field stack.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Thrift.Protocol.TCompactProtocol.WriteFieldBegin(Thrift.Protocol.TField)" -->
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteFieldBeginInternal(Thrift.Protocol.TField,System.Byte)">
            The workhorse of WriteFieldBegin. It has the option of doing a
            'type override' of the type header. This is used specifically in the
            boolean field case.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteFieldStop">
            Write the STOP symbol so we know there are no more fields in this struct.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteMapBegin(Thrift.Protocol.TMap)">
            Write a map header. If the map is empty, omit the key and value type
            headers, as we don't need any additional information to skip it.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteListBegin(Thrift.Protocol.TList)">
            Write a list header.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteSetBegin(Thrift.Protocol.TSet)">
            Write a set header.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteBool(System.Boolean)">
            Write a boolean value. Potentially, this could be a boolean field, in
            which case the field header info isn't written yet. If so, decide what the
            right type header is for the value and then Write the field header.
            Otherwise, Write a single byte.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteByte(System.SByte)">
            Write a byte. Nothing to see here!
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteI16(System.Int16)">
            Write an I16 as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteI32(System.Int32)">
            Write an i32 as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteI64(System.Int64)">
            Write an i64 as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteDouble(System.Double)">
            Write a double to the wire as 8 bytes.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteString(System.String)">
            Write a string to the wire with a varint size preceding.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteBinary(System.Byte[])">
            Write a byte array, using a varint for the size.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteCollectionBegin(Thrift.Protocol.TType,System.Int32)">
            Abstract method for writing the start of lists and sets. List and sets on
            the wire differ only by the type indicator.
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.varint64out">
            Write an i64 as a varint. Results in 1-10 bytes on the wire.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.longToZigzag(System.Int64)">
            Convert l into a zigzag long. This allows negative numbers to be
            represented compactly as a varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.intToZigZag(System.Int32)">
            Convert n into a zigzag int. This allows negative numbers to be
            represented compactly as a varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.fixedLongToBytes(System.Int64,System.Byte[],System.Int32)">
            Convert a long into little-endian bytes in buf starting at off and going
            until off+7.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadMessageBegin">
            Read a message header.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadStructBegin">
            Read a struct begin. There's nothing on the wire for this, but it is our
            opportunity to push a new struct begin marker onto the field stack.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadStructEnd">
            Doesn't actually consume any wire data, just removes the last field for
            this struct from the field stack.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadFieldBegin">
            Read a field header off the wire.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadMapBegin">
            Read a map header off the wire. If the size is zero, skip Reading the key
            and value type. This means that 0-length maps will yield TMaps without the
            "correct" types.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadListBegin">
            Read a list header off the wire. If the list size is 0-14, the size will
            be packed into the element type header. If it's a longer list, the 4 MSB
            of the element type header will be 0xF, and a varint will follow with the
            true size.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadSetBegin">
            Read a set header off the wire. If the set size is 0-14, the size will
            be packed into the element type header. If it's a longer set, the 4 MSB
            of the element type header will be 0xF, and a varint will follow with the
            true size.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadBool">
            Read a boolean off the wire. If this is a boolean field, the value should
            already have been Read during ReadFieldBegin, so we'll just consume the
            pre-stored value. Otherwise, Read a byte.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadByte">
            Read a single byte off the wire. Nothing interesting here.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadI16">
            Read an i16 from the wire as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadI32">
            Read an i32 from the wire as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadI64">
            Read an i64 from the wire as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadDouble">
            No magic here - just Read a double off the wire.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadString">
            Reads a byte[] (via ReadBinary), and then UTF-8 decodes it.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadBinary">
            Read a byte[] from the wire.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadBinary(System.Int32)">
            Read a byte[] of a known length from the wire.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadVarint32">
            Read an i32 from the wire as a varint. The MSB of each byte is set
            if there is another byte to follow. This can Read up to 5 bytes.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadVarint64">
            Read an i64 from the wire as a proper varint. The MSB of each byte is set
            if there is another byte to follow. This can Read up to 10 bytes.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.zigzagToInt(System.UInt32)">
            Convert from zigzag int to int.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.zigzagToLong(System.UInt64)">
            Convert from zigzag long to long.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.bytesToLong(System.Byte[])">
            Note that it's important that the mask bytes are long literals,
            otherwise they'll default to ints, and when you shift an int left 56 bits,
            you just get a messed up int.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.getTType(System.Byte)">
            Given a TCompactProtocol.Types constant, convert it to its corresponding
            TType value.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.getCompactType(Thrift.Protocol.TType)">
            Given a TType value, find the appropriate TCompactProtocol.Types constant.
        </member>
        <member name="T:Thrift.Protocol.TMultiplexedProcessor">
             TMultiplexedProcessor is a TProcessor allowing a single TServer to provide multiple services.
             To do so, you instantiate the processor and then register additional processors with it,
             as shown in the following example:
            
                 TMultiplexedProcessor processor = new TMultiplexedProcessor();
            
                 processor.registerProcessor(
                     "Calculator",
                     new Calculator.Processor(new CalculatorHandler()));
            
                 processor.registerProcessor(
                     "WeatherReport",
                     new WeatherReport.Processor(new WeatherReportHandler()));
            
                 TServerTransport t = new TServerSocket(9090);
                 TSimpleServer server = new TSimpleServer(processor, t);
            
                 server.serve();
        </member>
        <member name="M:Thrift.Protocol.TMultiplexedProcessor.RegisterProcessor(System.String,Thrift.TProcessor)">
             'Register' a service with this TMultiplexedProcessor. This allows us to broker
             requests to individual services by using the service name to select them at request time.
            
             Args:
             - serviceName    Name of a service, has to be identical to the name
                              declared in the Thrift IDL, e.g. "WeatherReport".
             - processor      Implementation of a service, usually referred to as "handlers",
                              e.g. WeatherReportHandler implementing WeatherReport.Iface.
        </member>
        <member name="M:Thrift.Protocol.TMultiplexedProcessor.Process(Thrift.Protocol.TProtocol,Thrift.Protocol.TProtocol)">
             This implementation of process performs the following steps:
            
             - Read the beginning of the message.
             - Extract the service name from the message.
             - Using the service name to locate the appropriate processor.
             - Dispatch to the processor, with a decorated instance of TProtocol
                that allows readMessageBegin() to return the original TMessage.
            
             Throws an exception if
             - the message type is not CALL or ONEWAY,
             - the service name was not found in the message, or
             - the service name has not been RegisterProcessor()ed.
        </member>
        <member name="T:Thrift.Protocol.TMultiplexedProcessor.StoredMessageProtocol">
            Our goal was to work with any protocol.  In order to do that, we needed
            to allow them to call readMessageBegin() and get a TMessage in exactly
            the standard format, without the service name prepended to TMessage.name.
        </member>
        <member name="T:Thrift.Protocol.TMultiplexedProtocol">
             TMultiplexedProtocol is a protocol-independent concrete decorator that allows a Thrift
             client to communicate with a multiplexing Thrift server, by prepending the service name
             to the function name during function calls.
            
             NOTE: THIS IS NOT TO BE USED BY SERVERS.
             On the server, use TMultiplexedProcessor to handle requests from a multiplexing client.
            
             This example uses a single socket transport to invoke two services:
            
                 TSocket transport = new TSocket("localhost", 9090);
                 transport.open();
            
                 TBinaryProtocol protocol = new TBinaryProtocol(transport);
            
                 TMultiplexedProtocol mp = new TMultiplexedProtocol(protocol, "Calculator");
                 Calculator.Client service = new Calculator.Client(mp);
            
                 TMultiplexedProtocol mp2 = new TMultiplexedProtocol(protocol, "WeatherReport");
                 WeatherReport.Client service2 = new WeatherReport.Client(mp2);
            
                 System.out.println(service.add(2,2));
                 System.out.println(service2.getTemperature());
            
        </member>
        <member name="F:Thrift.Protocol.TMultiplexedProtocol.SEPARATOR">
            Used to delimit the service name from the function name 
        </member>
        <member name="M:Thrift.Protocol.TMultiplexedProtocol.#ctor(Thrift.Protocol.TProtocol,System.String)">
             Wrap the specified protocol, allowing it to be used to communicate with a
             multiplexing server.  The <code>serviceName</code> is required as it is
             prepended to the message header so that the multiplexing server can broker
             the function call to the proper service.
            
             Args:
              protocol        Your communication protocol of choice, e.g. TBinaryProtocol
              serviceName     The service name of the service communicating via this protocol.
        </member>
        <member name="M:Thrift.Protocol.TMultiplexedProtocol.WriteMessageBegin(Thrift.Protocol.TMessage)">
            Prepends the service name to the function name, separated by TMultiplexedProtocol.SEPARATOR.
            Args:
              tMessage     The original message.
        </member>
        <member name="T:Thrift.Protocol.TProtocolDecorator">
             TProtocolDecorator forwards all requests to an enclosed TProtocol instance,
             providing a way to author concise concrete decorator subclasses.  While it has
             no abstract methods, it is marked abstract as a reminder that by itself,
             it does not modify the behaviour of the enclosed TProtocol.
            
             See p.175 of Design Patterns (by Gamma et al.)
             See TMultiplexedProtocol
        </member>
        <member name="M:Thrift.Protocol.TProtocolDecorator.#ctor(Thrift.Protocol.TProtocol)">
            Encloses the specified protocol.
            @param protocol All operations will be forward to this protocol.  Must be non-null.
        </member>
        <member name="T:Parquet.CompressionMethod">
            <summary>
            Parquet compression method
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.None">
            <summary>
            No compression
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Gzip">
            <summary>
            Gzip compression
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Snappy">
            <summary>
            Snappy compression 
            </summary>
        </member>
        <member name="T:Parquet.Data.DataSet">
            <summary>
            Represents a data set
            </summary>
        </member>
        <member name="M:Parquet.Data.DataSet.#ctor(Parquet.Data.Schema)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.DataSet"/> class.
            </summary>
            <param name="schema">The schema.</param>
        </member>
        <member name="M:Parquet.Data.DataSet.#ctor(System.Collections.Generic.IEnumerable{Parquet.Data.Field})">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.DataSet"/> class.
            </summary>
            <param name="schema">The schema.</param>
        </member>
        <member name="M:Parquet.Data.DataSet.#ctor(Parquet.Data.Field[])">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.DataSet"/> class.
            </summary>
            <param name="schema">The schema.</param>
        </member>
        <member name="P:Parquet.Data.DataSet.Schema">
            <summary>
            Gets dataset schema
            </summary>
        </member>
        <member name="P:Parquet.Data.DataSet.Metadata">
            <summary>
            Gets the public metadata
            </summary>
        </member>
        <member name="P:Parquet.Data.DataSet.TotalRowCount">
            <summary>
            Gets the total row count in the source file this dataset was read from
            </summary>
        </member>
        <member name="M:Parquet.Data.DataSet.GetColumn(Parquet.Data.DataField,System.Int32,System.Int32)">
            <summary>
            Slices rows and returns list of all values in a particular column.
            </summary>
            <param name="schemaElement">Schema element</param>
            <param name="offset">The offset.</param>
            <param name="count">The count.</param>
            <returns>
            Column values
            </returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Parquet.Data.DataSet.GetColumn``1(Parquet.Data.DataField)">
            <summary>
            Gets the column as strong typed collection
            </summary>
            <typeparam name="T">Column element type</typeparam>
            <param name="schemaElement">Column schema</param>
            <returns>Strong typed collection</returns>
        </member>
        <member name="M:Parquet.Data.DataSet.Add(System.Object[])">
            <summary>
            Adds the specified values.
            </summary>
            <param name="values">The values.</param>
        </member>
        <member name="M:Parquet.Data.DataSet.Merge(Parquet.Data.DataSet)">
            <summary>
            Merges dataset into this dataset
            </summary>
            <param name="source">DataSet to take the data from</param>
        </member>
        <member name="M:Parquet.Data.DataSet.ToString">
            <summary>
            Displays some DataSet rows
            </summary>
            <returns></returns>
        </member>
        <member name="P:Parquet.Data.DataSet.Item(System.Int32)">
            <summary>
            Gets or sets row by index
            </summary>
            <param name="index">Row index</param>
            <returns>Row object</returns>
        </member>
        <member name="P:Parquet.Data.DataSet.Count">
            <summary>
            Gets the number of rows contained in this dataset
            </summary>
        </member>
        <member name="P:Parquet.Data.DataSet.RowCount">
            <summary>
            Gets the number of rows contained in this dataset.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataSet.FieldCount">
            <summary>
            Gets the number of columns contained in this dataset
            </summary>
        </member>
        <member name="P:Parquet.Data.DataSet.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
        </member>
        <member name="M:Parquet.Data.DataSet.Add(Parquet.Data.Row)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        </member>
        <member name="M:Parquet.Data.DataSet.Clear">
            <summary>
            Clears data in the dataset
            </summary>
        </member>
        <member name="M:Parquet.Data.DataSet.Contains(Parquet.Data.Row)">
            <summary>
            This operation is not supported
            </summary>
        </member>
        <member name="M:Parquet.Data.DataSet.CopyTo(Parquet.Data.Row[],System.Int32)">
            <summary>
            This operation is not supported
            </summary>
        </member>
        <member name="M:Parquet.Data.DataSet.GetEnumerator">
            <summary>
            Gets enumerator I guess
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.DataSet.IndexOf(Parquet.Data.Row)">
            <summary>
            This operation is not supported
            </summary>
        </member>
        <member name="M:Parquet.Data.DataSet.Insert(System.Int32,Parquet.Data.Row)">
            <summary>
            Inserts a new row, not implemented
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Parquet.Data.DataSet.Remove(Parquet.Data.Row)">
            <summary>
            This operation is not supported
            </summary>
        </member>
        <member name="M:Parquet.Data.DataSet.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
        </member>
        <member name="T:Parquet.Data.DataSetMetadata">
            <summary>
            Public metadata
            </summary>
        </member>
        <member name="P:Parquet.Data.DataSetMetadata.CreatedBy">
            <summary>
            Gets the creator tag.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataSetMetadata.Custom">
            <summary>
            Custom metadata properties
            </summary>
        </member>
        <member name="T:Parquet.Data.DataType">
            <summary>
            List of supported data types
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Boolean">
            <summary>
            Boolean
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Byte">
            <summary>
            Byte
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.SignedByte">
            <summary>
            Signed byte data type
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedByte">
            <summary>
            Unsigned byte
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Short">
            <summary>
            Short
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedShort">
            <summary>
            Unsigned short
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int16">
            <summary>
            16 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedInt16">
            <summary>
            16 bit unsigned integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int32">
            <summary>
            32 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int64">
            <summary>
            64 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int96">
            <summary>
            96 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.ByteArray">
            <summary>
            Array of bytes
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.String">
            <summary>
            UTF-8 string
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Float">
            <summary>
            Float
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Double">
            <summary>
            Double
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Decimal">
            <summary>
            Decimal
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.DateTimeOffset">
            <summary>
            DateTimeOffset
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Interval">
            <summary>
            Interval
            </summary>
        </member>
        <member name="T:Parquet.Data.DateTimeFormat">
            <summary>
            Choice of representing dates
            </summary>
        </member>
        <member name="F:Parquet.Data.DateTimeFormat.Impala">
            <summary>
            The impala compatible date, which maps to INT96. This is the default datetime representation.
            </summary>
        </member>
        <member name="F:Parquet.Data.DateTimeFormat.DateAndTime">
            <summary>
            This is the default Parquet datetime representation, but not default option for saving which is <see cref="F:Parquet.Data.DateTimeFormat.Impala"/>.
            Stores date and time up to millisecond precision as INT64
            </summary>
        </member>
        <member name="F:Parquet.Data.DateTimeFormat.Date">
            <summary>
            Only stores a date. Time portion is truncated. Internally stored as INT32
            </summary>
        </member>
        <member name="T:Parquet.Data.IDataTypeHandler">
            <summary>
            Prototype: data type interface
            </summary>
        </member>
        <member name="M:Parquet.Data.IDataTypeHandler.IsMatch(Parquet.Thrift.SchemaElement,Parquet.ParquetOptions)">
            <summary>
            Called by the library to determine if this data handler can be used in current schema position
            </summary>
            <param name="tse"></param>
            <param name="formatOptions"></param>
            <returns></returns>
        </member>
        <member name="T:Parquet.Data.Row">
            <summary>
            Represents a row
            </summary>
        </member>
        <member name="M:Parquet.Data.Row.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Row"/> class.
            </summary>
            <param name="values">The values.</param>
        </member>
        <member name="M:Parquet.Data.Row.#ctor(System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Row"/> class.
            </summary>
            <param name="values">The values.</param>
        </member>
        <member name="P:Parquet.Data.Row.Length">
            <summary>
            Gets the number of values in this row
            </summary>
        </member>
        <member name="P:Parquet.Data.Row.Item(System.Int32)">
            <summary>
            Gets the row value by index
            </summary>
        </member>
        <member name="M:Parquet.Data.Row.GetBoolean(System.Int32)">
            <summary>
            Gets the value as boolean
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Row.GetInt(System.Int32)">
            <summary>
            Gets the value as integer
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Row.GetFloat(System.Int32)">
            <summary>
            Gets the value as float
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Row.GetLong(System.Int32)">
            <summary>
            Gets the value as long
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Row.GetDouble(System.Int32)">
            <summary>
            Gets the value as double
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Row.GetBigInt(System.Int32)">
            <summary>
            Gets the value as big integer
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Row.GetByteArray(System.Int32)">
            <summary>
            Gets the value as byte array
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Row.GetString(System.Int32)">
            <summary>
            Gets the value as string
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Row.GetDateTimeOffset(System.Int32)">
            <summary>
            Gets the value as <see cref="T:System.DateTimeOffset"/>
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Row.IsNullAt(System.Int32)">
            <summary>
            Returns true if value at column <paramref name="i"/> is NULL.
            </summary>
        </member>
        <member name="M:Parquet.Data.Row.Get``1(System.Int32)">
            <summary>
            Gets the value trying to cast to <typeparamref name="T"/>
            </summary>
            <param name="i">Value index</param>
            <exception cref="T:System.ArgumentException">Cannot cast <typeparamref name="T"/></exception>
        </member>
        <member name="P:Parquet.Data.Row.RawValues">
            <summary>
            Gets the raw values.
            </summary>
        </member>
        <member name="M:Parquet.Data.Row.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Parquet.Data.SchemaType">
            <summary>
            Type of schema
            </summary>
        </member>
        <member name="F:Parquet.Data.SchemaType.Data">
            <summary>
            Contains actual values i.e. declared by a <see cref="T:Parquet.Data.DataField"/>
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.DataType">
            <summary>
            Data type of this element
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.HasNulls">
            <summary>
            When true, this element is allowed to have nulls
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.IsArray">
            <summary>
            When true, the value is an array rather than a single value.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.ClrType">
            <summary>
            CLR type of this column. Not sure whether to expose this externally yet.
            </summary>
        </member>
        <member name="M:Parquet.Data.DataField.ToString">
            <summary>
            Pretty prints
            </summary>
        </member>
        <member name="M:Parquet.Data.DataField.Equals(Parquet.Data.DataField)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Parquet.Data.DataField.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Parquet.Data.DataField.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="T:Parquet.Data.DataField`1">
            <summary>
            Element of dataset's schema. Provides a helper way to construct a schema element with .NET generics.
            <typeparamref name="T">Type of element in the column</typeparamref>
            </summary>
        </member>
        <member name="M:Parquet.Data.DataField`1.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Field"/> class.
            </summary>
            <param name="name">Column name</param>
        </member>
        <member name="T:Parquet.Data.DateTimeDataField">
            <summary>
            Schema element for <see cref="T:System.DateTimeOffset"/> which allows to specify precision
            </summary>
        </member>
        <member name="P:Parquet.Data.DateTimeDataField.DateTimeFormat">
            <summary>
            Desired data format, Parquet specific
            </summary>
        </member>
        <member name="M:Parquet.Data.DateTimeDataField.#ctor(System.String,Parquet.Data.DateTimeFormat,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.DateTimeDataField"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="format">The format.</param>
            <param name="hasNulls">Is 'DateTime?'</param>
            <param name="isArray"></param>
        </member>
        <member name="T:Parquet.Data.DecimalDataField">
            <summary>
            Maps to Parquet decimal type, allowing to specify custom scale and precision
            </summary>
        </member>
        <member name="M:Parquet.Data.DecimalDataField.#ctor(System.String,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructs class instance
            </summary>
            <param name="name">The name of the column</param>
            <param name="precision">Cusom precision</param>
            <param name="scale">Custom scale</param>
            <param name="forceByteArrayEncoding">Whether to force decimal type encoding as fixed bytes. Hive and Impala only understands decimals when forced to true.</param>
            <param name="nullable">Is 'decimal?'</param>
        </member>
        <member name="T:Parquet.Data.Field">
            <summary>
            Element of dataset's schema
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.SchemaType">
            <summary>
            Type of schema in this field
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.Name">
            <summary>
            Column name
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.Path">
            <summary>
            Only used internally!
            </summary>
        </member>
        <member name="M:Parquet.Data.Field.#ctor(System.String,Parquet.Data.SchemaType)">
            <summary>
            Constructs a field with only requiremd parameters
            </summary>
            <param name="name">Field name, required</param>
            <param name="schemaType">Type of schema of this field</param>
        </member>
        <member name="T:Parquet.Data.ListField">
            <summary>
            Represents a list of items. The list can contain either a normal data field or a complex structure.
            If you need to get a list of primitive data fields it's more efficient to use arrays.
            </summary>
        </member>
        <member name="P:Parquet.Data.ListField.Item">
            <summary>
            Item contained within this list
            </summary>
        </member>
        <member name="T:Parquet.Data.Schema">
            <summary>
            Represents dataset schema
            </summary>
        </member>
        <member name="F:Parquet.Data.Schema.PathSeparator">
            <summary>
            Symbol used to separate path parts in schema element path
            </summary>
        </member>
        <member name="F:Parquet.Data.Schema.PathSeparatorChar">
            <summary>
            Character used to separate path parts in schema element path
            </summary>
        </member>
        <member name="M:Parquet.Data.Schema.#ctor(System.Collections.Generic.IEnumerable{Parquet.Data.Field})">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Schema"/> class from schema elements.
            </summary>
            <param name="fields">The elements.</param>
        </member>
        <member name="M:Parquet.Data.Schema.#ctor(Parquet.Data.Field[])">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Schema"/> class.
            </summary>
            <param name="fields">The elements.</param>
        </member>
        <member name="P:Parquet.Data.Schema.Fields">
            <summary>
            Gets the schema elements
            </summary>
        </member>
        <member name="P:Parquet.Data.Schema.Length">
            <summary>
            Gets the number of elements in the schema
            </summary>
        </member>
        <member name="P:Parquet.Data.Schema.FieldNames">
            <summary>
            Gets the column names as string array
            </summary>
        </member>
        <member name="P:Parquet.Data.Schema.Item(System.Int32)">
            <summary>
            Get schema element by index
            </summary>
            <param name="i">Index of schema element</param>
            <returns>Schema element</returns>
        </member>
        <member name="P:Parquet.Data.Schema.Item(System.String)">
            <summary>
            Get schema element by name
            </summary>
            <param name="name">Schema element name</param>
            <returns>Schema element</returns>
        </member>
        <member name="M:Parquet.Data.Schema.GetFieldIndex(Parquet.Data.Field)">
            <summary>
            Gets the column index by schema element
            </summary>
            <returns>Element index or -1 if not found</returns>
        </member>
        <member name="M:Parquet.Data.Schema.Equals(Parquet.Data.Schema)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Parquet.Data.Schema.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Parquet.Data.Schema.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:Parquet.Data.StructField">
            <summary>
            Represents a structure i.e. a container for other fields.
            </summary>
        </member>
        <member name="M:Parquet.Data.StructField.#ctor(System.String,Parquet.Data.Field[])">
            <summary>
            Creates a new structure field 
            </summary>
            <param name="name">Structure name</param>
            <param name="elements">List of elements</param>
        </member>
        <member name="P:Parquet.Data.StructField.Fields">
            <summary>
            Elements of this structure
            </summary>
        </member>
        <member name="T:Parquet.ThriftExtensions">
            <summary>
            Internal thrift data structure helpers
            </summary>
        </member>
        <member name="M:Parquet.File.ColumnarReader.ReadLevels(System.IO.BinaryReader,System.Int32,System.Int32)">
            <summary>
            Reads levels, suitable for both repetition levels and definition levels
            </summary>
            <param name="reader"></param>
            <param name="maxLevel">Maximum level value, depends on level type</param>
            <param name="maxValues">Maximum number of values, so result can be trimmed when it's exceeded</param>
            <returns></returns>
        </member>
        <member name="T:Parquet.File.DefinitionPack">
            <summary>
            Packs/unpacks definition levels
            </summary>
        </member>
        <member name="M:Parquet.File.DefinitionPack.RemoveNulls(System.Collections.IList,System.Int32,System.Collections.Generic.List{System.Boolean})">
            <summary>
            
            </summary>
            <param name="values">Values to compress. This operation modifies the list</param>
            <param name="maxDefinitionLevel"></param>
            <param name="hasValueFlags">Indicates where values are present and where not, optional.</param>
            <returns>Definitions for the input values</returns>
        </member>
        <member name="T:Parquet.File.RepetitionPack">
            <summary>
            Packs/unpacks repetition levels
            </summary>
        </member>
        <member name="T:Parquet.File.ThriftStream">
            <summary>
            Utility methods to work with Thrift data in a stream
            </summary>
        </member>
        <member name="M:Parquet.File.ThriftStream.Read``1">
            <summary>
            Reads typed structure from incoming stream
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Parquet.File.ThriftStream.Write``1(``0,System.Boolean)">
            <summary>
            Writes types structure to the destination stream
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <param name="rewind">When true, rewinds to the original position before writing</param>
            <returns>Actual size of the object written</returns>
        </member>
        <member name="T:Parquet.File.ValueMerger">
            <summary>
            Responsible for merging values from different parts of column parts (repetition, definitions etc.)
            </summary>
        </member>
        <member name="M:Parquet.File.ValueMerger.Apply(System.Collections.IList,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Applies dictionary with indexes and definition levels directly over the column
            </summary>
        </member>
        <member name="T:Parquet.File.Values.Primitives.BigDecimal">
            <summary>
            A class that encapsulates BigDecimal like the java class
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.DecimalValue">
            <summary>
            Contains a Decimal value that is the big integer
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.Scale">
            <summary>
            The scale of the decimal value
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.Precision">
            <summary>
            The precision of the decimal value
            </summary>
        </member>
        <member name="M:Parquet.File.Values.Primitives.BigDecimal.op_Implicit(Parquet.File.Values.Primitives.BigDecimal)~System.Decimal">
            <summary>
            Converts a BigDecimal to a decimal
            </summary>
            <param name="bd">The BigDecimal value</param>
        </member>
        <member name="M:Parquet.File.Values.Primitives.BigDecimal.GetBufferSize(System.Int32)">
            <summary>
            Gets buffer size enough to be able to hold the decimal number of a specific precision
            </summary>
            <param name="precision">Precision value</param>
            <returns>Length in bytes</returns>
        </member>
        <member name="T:Parquet.File.Values.Primitives.Interval">
            <summary>
            A parquet interval type compatible with a Spark INTERVAL type
            12 byte little Endian structure fits in an INT96 original type with an INTERVAL converted type
            </summary>
        </member>
        <member name="M:Parquet.File.Values.Primitives.Interval.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Used to create an interval type
            </summary>
            <param name="months">The month interval</param>
            <param name="days">The days interval</param>
            <param name="millis">The milliseconds interval</param>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Millis">
            <summary>
            Returns the number of milliseconds in the type
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Days">
            <summary>
            Returns the number of days in the type
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Months">
            <summary>
            Returns the number of months in type
            </summary>
        </member>
        <member name="M:Parquet.File.Values.RunLengthBitPackingHybridValuesReader.ReadRle(System.Int32,System.IO.BinaryReader,System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Read run-length encoded run from the given header and bit length.
            </summary>
        </member>
        <member name="M:Parquet.File.Values.RunLengthBitPackingHybridValuesReader.ReadUnsignedVarInt(System.IO.BinaryReader)">
            <summary>
            Read a value using the unsigned, variable int encoding.
            </summary>
        </member>
        <member name="T:Parquet.ParquetActor">
            <summary>
            Base class for reader and writer
            </summary>
        </member>
        <member name="P:Parquet.ParquetActor.Stream">
            <summary>
            Original stream to write or read
            </summary>
        </member>
        <member name="T:Parquet.ParquetException">
            <summary>
            Parquet format specific
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor(System.String)">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="T:Parquet.ParquetOptions">
            <summary>
            Parquet options
            </summary>
        </member>
        <member name="M:Parquet.ParquetOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.ParquetOptions"/> class.
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.TreatByteArrayAsString">
            <summary>
            When true byte arrays will be treated as UTF-8 strings
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.TreatBigIntegersAsDates">
            <summary>
            Gets or sets a value indicating whether big integers are always treated as dates
            </summary>
        </member>
        <member name="T:Parquet.ParquetReader">
            <summary>
            Implements Apache Parquet format reader
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.#ctor(System.IO.Stream,Parquet.ParquetOptions,Parquet.ReaderOptions)">
            <summary>
            Creates an instance from input stream
            </summary>
            <param name="input">Input stream, must be readable and seekable</param>
            <param name="formatOptions">Optional reader options</param>
            <param name="readerOptions">The reader options.</param>
            <exception cref="T:System.ArgumentNullException">input</exception>
            <exception cref="T:System.ArgumentException">stream must be readable and seekable - input</exception>
            <exception cref="T:System.IO.IOException">not a Parquet file (size too small)</exception>
        </member>
        <member name="M:Parquet.ParquetReader.ReadFile(System.String,Parquet.ParquetOptions,Parquet.ReaderOptions)">
            <summary>
            Reads the file
            </summary>
            <param name="fullPath">The full path.</param>
            <param name="formatOptions">Optional reader options.</param>
            <param name="readerOptions">The reader options.</param>
            <returns><see cref="T:Parquet.Data.DataSet"/></returns>
        </member>
        <member name="M:Parquet.ParquetReader.Read(System.IO.Stream,Parquet.ParquetOptions,Parquet.ReaderOptions)">
            <summary>
            Reads <see cref="T:Parquet.Data.DataSet"/> from an open stream
            </summary>
            <param name="source">Input stream</param>
            <param name="formatOptions">Parquet options, optional.</param>
            <param name="readerOptions">Reader options, optional</param>
            <returns><see cref="T:Parquet.Data.DataSet"/></returns>
        </member>
        <member name="M:Parquet.ParquetReader.Read">
            <summary>
            Test read, to be defined
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.Dispose">
            <summary>
            Disposes 
            </summary>
        </member>
        <member name="T:Parquet.ParquetWriter">
            <summary>
            Implements Apache Parquet format writer
            </summary>
        </member>
        <member name="M:Parquet.ParquetWriter.#ctor(System.IO.Stream,Parquet.ParquetOptions,Parquet.WriterOptions)">
            <summary>
            Creates an instance of parquet writer on top of a stream
            </summary>
            <param name="output">Writeable, seekable stream</param>
            <param name="formatOptions">Additional options</param>
            <param name="writerOptions">The writer options.</param>
            <exception cref="T:System.ArgumentNullException">Output is null.</exception>
            <exception cref="T:System.ArgumentException">Output stream is not writeable</exception>
        </member>
        <member name="M:Parquet.ParquetWriter.Write(Parquet.Data.DataSet,Parquet.CompressionMethod,System.Boolean)">
            <summary>
            Write out dataset to the output stream
            </summary>
            <param name="dataSet">Dataset to write</param>
            <param name="compression">Compression method</param>
            <param name="append">When true, appends to the file, otherwise creates a new file.</param>
        </member>
        <member name="M:Parquet.ParquetWriter.Write(Parquet.Data.DataSet,System.IO.Stream,Parquet.CompressionMethod,Parquet.ParquetOptions,Parquet.WriterOptions,System.Boolean)">
            <summary>
            Writes <see cref="T:Parquet.Data.DataSet"/> to a target stream
            </summary>
            <param name="dataSet"><see cref="T:Parquet.Data.DataSet"/> to write</param>
            <param name="destination">Destination stream</param>
            <param name="compression">Compression method</param>
            <param name="formatOptions">Parquet options, optional.</param>
            <param name="writerOptions">Writer options, optional.</param>
            <param name="append">When true, assumes that this stream contains existing file and appends data to it, otherwise writes a new Parquet file.</param>
        </member>
        <member name="M:Parquet.ParquetWriter.WriteFile(Parquet.Data.DataSet,System.String,Parquet.CompressionMethod,Parquet.ParquetOptions,Parquet.WriterOptions,System.Boolean)">
            <summary>
            Writes <see cref="T:Parquet.Data.DataSet"/> to a target file
            </summary>
            <param name="dataSet"><see cref="T:Parquet.Data.DataSet"/> to write</param>
            <param name="fileName">Path to a file to write to.</param>
            <param name="compression">Compression method</param>
            <param name="formatOptions">Parquet options, optional.</param>
            <param name="writerOptions">Writer options, optional.</param>
            <param name="append">When true, assumes that this stream contains existing file and appends data to it, otherwise writes a new Parquet file.</param>
        </member>
        <member name="M:Parquet.ParquetWriter.Dispose">
            <summary>
            Finalizes file, writes metadata and footer
            </summary>
        </member>
        <member name="T:Parquet.ReaderOptions">
            <summary>
            Reader options
            </summary>
        </member>
        <member name="M:Parquet.ReaderOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.ReaderOptions"/> class.
            </summary>
        </member>
        <member name="P:Parquet.ReaderOptions.Offset">
            <summary>
            Gets or sets the offset.
            </summary>
        </member>
        <member name="P:Parquet.ReaderOptions.Count">
            <summary>
            Gets or sets the count.
            </summary>
        </member>
        <member name="P:Parquet.ReaderOptions.Columns">
            <summary>
            Gets or sets the names of columns to read. If not set (default) all the columns will be read. 
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.File_path">
            <summary>
            File where column data is stored.  If not set, assumed to be same file as
            metadata.  This path is relative to the current file.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.File_offset">
            <summary>
            Byte offset in file_path to the ColumnMetaData *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Meta_data">
            <summary>
            Column metadata for this chunk. This is the same content as what is at
            file_path/file_offset.  Having it here has it replicated in the file
            metadata.
            
            </summary>
        </member>
        <member name="T:Parquet.Thrift.ColumnMetaData">
            <summary>
            Description for column metadata
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Type">
            <summary>
            Type of this column *
            
            <seealso cref="P:Parquet.Thrift.ColumnMetaData.Type"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Encodings">
            <summary>
            Set of all encodings used for this column. The purpose is to validate
            whether we can decode those pages. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Path_in_schema">
            <summary>
            Path in schema *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Codec">
            <summary>
            Compression codec *
            
            <seealso cref="T:Parquet.Thrift.CompressionCodec"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Num_values">
            <summary>
            Number of values in this column *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Total_uncompressed_size">
            <summary>
            total byte size of all uncompressed pages in this column chunk (including the headers) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Total_compressed_size">
            <summary>
            total byte size of all compressed pages in this column chunk (including the headers) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Key_value_metadata">
            <summary>
            Optional key/value metadata *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Data_page_offset">
            <summary>
            Byte offset from beginning of file to first data page *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Index_page_offset">
            <summary>
            Byte offset from beginning of file to root index page *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Dictionary_page_offset">
            <summary>
            Byte offset from the beginning of file to first (only) dictionary page *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Statistics">
            <summary>
            optional statistics for this column chunk
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Encoding_stats">
            <summary>
            Set of all encodings used for pages in this column chunk.
            This information can be used to determine if all data pages are
            dictionary encoded for example *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.CompressionCodec">
            <summary>
            Supported compression algorithms.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.ConvertedType">
            <summary>
            Common types used by frameworks(e.g. hive, pig) using parquet.  This helps map
            between types in those frameworks to the base types in parquet.  This is only
            metadata and not needed to read or write the data.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.UTF8">
            <summary>
            a BYTE_ARRAY actually contains UTF8 encoded chars
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.MAP">
            <summary>
            a map is converted as an optional field containing a repeated key/value pair
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.MAP_KEY_VALUE">
            <summary>
            a key/value pair is converted into a group of two fields
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.LIST">
            <summary>
            a list is converted into an optional field containing a repeated field for its
            values
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.ENUM">
            <summary>
            an enum is converted into a binary field
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.DECIMAL">
            <summary>
            A decimal value.
            
            This may be used to annotate binary or fixed primitive types. The
            underlying byte array stores the unscaled value encoded as two's
            complement using big-endian byte order (the most significant byte is the
            zeroth element). The value of the decimal is the value * 10^{-scale}.
            
            This must be accompanied by a (maximum) precision and a scale in the
            SchemaElement. The precision specifies the number of digits in the decimal
            and the scale stores the location of the decimal point. For example 1.23
            would have precision 3 (3 total digits) and scale 2 (the decimal point is
            2 digits over).
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.DATE">
            <summary>
            A Date
            
            Stored as days since Unix epoch, encoded as the INT32 physical type.
            
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.TIME_MILLIS">
            <summary>
            A time
            
            The total number of milliseconds since midnight.  The value is stored
            as an INT32 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.TIMESTAMP_MILLIS">
            <summary>
            A date/time combination
            
            Date and time recorded as milliseconds since the Unix epoch.  Recorded as
            a physical type of INT64.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.UINT_8">
            <summary>
            An unsigned integer value.
            
            The number describes the maximum number of meainful data bits in
            the stored value. 8, 16 and 32 bit values are stored using the
            INT32 physical type.  64 bit values are stored using the INT64
            physical type.
            
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.INT_8">
            <summary>
            A signed integer value.
            
            The number describes the maximum number of meainful data bits in
            the stored value. 8, 16 and 32 bit values are stored using the
            INT32 physical type.  64 bit values are stored using the INT64
            physical type.
            
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.JSON">
            <summary>
            An embedded JSON document
            
            A JSON document embedded within a single UTF8 column.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.BSON">
            <summary>
            An embedded BSON document
            
            A BSON document embedded within a single BINARY column.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.INTERVAL">
            <summary>
            An interval of time
            
            This type annotates data stored as a FIXED_LEN_BYTE_ARRAY of length 12
            This data is composed of three separate little endian unsigned
            integers.  Each stores a component of a duration of time.  The first
            integer identifies the number of months associated with the duration,
            the second identifies the number of days associated with the duration
            and the third identifies the number of milliseconds associated with
            the provided duration.  This duration of time is independent of any
            particular timezone or date.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.DataPageHeader">
            <summary>
            Data page header
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Num_values">
            <summary>
            Number of values, including NULLs, in this data page. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Encoding">
            <summary>
            Encoding used for this data page *
            
            <seealso cref="P:Parquet.Thrift.DataPageHeader.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Definition_level_encoding">
            <summary>
            Encoding used for definition levels *
            
            <seealso cref="P:Parquet.Thrift.DataPageHeader.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Repetition_level_encoding">
            <summary>
            Encoding used for repetition levels *
            
            <seealso cref="P:Parquet.Thrift.DataPageHeader.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Statistics">
            <summary>
            Optional statistics for the data in this page*
            </summary>
        </member>
        <member name="T:Parquet.Thrift.DataPageHeaderV2">
            <summary>
            New page format alowing reading levels without decompressing the data
            Repetition and definition levels are uncompressed
            The remaining section containing the data is compressed if is_compressed is true
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Num_values">
            <summary>
            Number of values, including NULLs, in this data page. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Num_nulls">
            <summary>
            Number of NULL values, in this data page.
            Number of non-null = num_values - num_nulls which is also the number of values in the data section *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Num_rows">
            <summary>
            Number of rows in this data page. which means pages change on record boundaries (r = 0) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Encoding">
            <summary>
            Encoding used for data in this page *
            
            <seealso cref="P:Parquet.Thrift.DataPageHeaderV2.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Definition_levels_byte_length">
            <summary>
            length of the repetition levels
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Repetition_levels_byte_length">
            <summary>
            length of the definition levels
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Is_compressed">
            <summary>
            whether the values are compressed.
            Which means the section of the page between
            definition_levels_byte_length + repetition_levels_byte_length + 1 and compressed_page_size (included)
            is compressed with the compression_codec.
            If missing it is considered compressed
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Statistics">
            <summary>
            optional statistics for this column chunk
            </summary>
        </member>
        <member name="T:Parquet.Thrift.DictionaryPageHeader">
            <summary>
            TODO: *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DictionaryPageHeader.Num_values">
            <summary>
            Number of values in the dictionary *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DictionaryPageHeader.Encoding">
            <summary>
            Encoding using this dictionary page *
            
            <seealso cref="P:Parquet.Thrift.DictionaryPageHeader.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DictionaryPageHeader.Is_sorted">
            <summary>
            If true, the entries in the dictionary are sorted in ascending order *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.Encoding">
            <summary>
            Encodings supported by Parquet.  Not all encodings are valid for all types.  These
            enums are also used to specify the encoding of definition and repetition levels.
            See the accompanying doc for the details of the more complicated encodings.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.PLAIN">
            <summary>
            Default encoding.
            BOOLEAN - 1 bit per value. 0 is false; 1 is true.
            INT32 - 4 bytes per value.  Stored as little-endian.
            INT64 - 8 bytes per value.  Stored as little-endian.
            FLOAT - 4 bytes per value.  IEEE. Stored as little-endian.
            DOUBLE - 8 bytes per value.  IEEE. Stored as little-endian.
            BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.
            FIXED_LEN_BYTE_ARRAY - Just the bytes.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.PLAIN_DICTIONARY">
            <summary>
            Deprecated: Dictionary encoding. The values in the dictionary are encoded in the
            plain type.
            in a data page use RLE_DICTIONARY instead.
            in a Dictionary page use PLAIN instead
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.RLE">
            <summary>
            Group packed run length encoding. Usable for definition/reptition levels
            encoding and Booleans (on one bit: 0 is false; 1 is true.)
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.BIT_PACKED">
            <summary>
            Bit packed encoding.  This can only be used if the data has a known max
            width.  Usable for definition/repetition levels encoding.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.DELTA_BINARY_PACKED">
            <summary>
            Delta encoding for integers. This can be used for int columns and works best
            on sorted data
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.DELTA_LENGTH_BYTE_ARRAY">
            <summary>
            Encoding for byte arrays to separate the length values and the data. The lengths
            are encoded using DELTA_BINARY_PACKED
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.DELTA_BYTE_ARRAY">
            <summary>
            Incremental-encoded byte array. Prefix lengths are encoded using DELTA_BINARY_PACKED.
            Suffixes are stored as delta length byte arrays.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.RLE_DICTIONARY">
            <summary>
            Dictionary encoding: the ids are encoded using the RLE encoding
            </summary>
        </member>
        <member name="T:Parquet.Thrift.FieldRepetitionType">
            <summary>
            Representation of Schemas
            </summary>
        </member>
        <member name="F:Parquet.Thrift.FieldRepetitionType.REQUIRED">
            <summary>
            This field is required (can not be null) and each record has exactly 1 value.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.FieldRepetitionType.OPTIONAL">
            <summary>
            The field is optional (can be null) and each record has 0 or 1 values.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.FieldRepetitionType.REPEATED">
            <summary>
            The field is repeated and can contain 0 or more values
            </summary>
        </member>
        <member name="T:Parquet.Thrift.FileMetaData">
            <summary>
            Description for file metadata
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Version">
            <summary>
            Version of this file *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Schema">
            <summary>
            Parquet schema for this file.  This schema contains metadata for all the columns.
            The schema is represented as a tree with a single root.  The nodes of the tree
            are flattened to a list by doing a depth-first traversal.
            The column metadata contains the path in the schema for that column which can be
            used to map columns to nodes in the schema.
            The first element is the root *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Num_rows">
            <summary>
            Number of rows in this file *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Row_groups">
            <summary>
            Row groups in this file *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Key_value_metadata">
            <summary>
            Optional key/value metadata *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Created_by">
            <summary>
            String for application that wrote this file.  This should be in the format
            [Application] version [App Version] (build [App Build Hash]).
            e.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55)
            </summary>
        </member>
        <member name="T:Parquet.Thrift.KeyValue">
            <summary>
            Wrapper struct to store key values
            </summary>
        </member>
        <member name="T:Parquet.Thrift.PageEncodingStats">
            <summary>
            statistics of a given page type and encoding
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageEncodingStats.Page_type">
            <summary>
            the page type (data/dic/...) *
            
            <seealso cref="T:Parquet.Thrift.PageType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageEncodingStats.Encoding">
            <summary>
            encoding of the page *
            
            <seealso cref="P:Parquet.Thrift.PageEncodingStats.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageEncodingStats.Count">
            <summary>
            number of pages of this type with this encoding *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Type">
            <summary>
            the type of the page: indicates which of the *_header fields is set *
            
            <seealso cref="T:Parquet.Thrift.PageType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Uncompressed_page_size">
            <summary>
            Uncompressed page size in bytes (not including this header) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Compressed_page_size">
            <summary>
            Compressed page size in bytes (not including this header) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Crc">
            <summary>
            32bit crc for the data below. This allows for disabling checksumming in HDFS
            if only a few pages needs to be read
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Total_byte_size">
            <summary>
            Total byte size of all the uncompressed column data in this row group *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Num_rows">
            <summary>
            Number of rows in this row group *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Sorting_columns">
            <summary>
            If set, specifies a sort ordering of the rows in this RowGroup.
            The sorting columns can be a subset of all the columns.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.SchemaElement">
            <summary>
            Represents a element inside a schema definition.
             - if it is a group (inner node) then type is undefined and num_children is defined
             - if it is a primitive type (leaf) then type is defined and num_children is undefined
            the nodes are listed in depth first traversal order.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Type">
            <summary>
            Data type for this field. Not set if the current element is a non-leaf node
            
            <seealso cref="P:Parquet.Thrift.SchemaElement.Type"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Type_length">
            <summary>
            If type is FIXED_LEN_BYTE_ARRAY, this is the byte length of the vales.
            Otherwise, if specified, this is the maximum bit length to store any of the values.
            (e.g. a low cardinality INT col could have this set to 3).  Note that this is
            in the schema, and therefore fixed for the entire file.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Repetition_type">
            <summary>
            repetition of the field. The root of the schema does not have a repetition_type.
            All other nodes must have one
            
            <seealso cref="T:Parquet.Thrift.FieldRepetitionType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Name">
            <summary>
            Name of the field in the schema
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Num_children">
            <summary>
            Nested fields.  Since thrift does not support nested fields,
            the nesting is flattened to a single list by a depth-first traversal.
            The children count is used to construct the nested relationship.
            This field is not set when the element is a primitive type
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Converted_type">
            <summary>
            When the schema is the result of a conversion from another model
            Used to record the original type to help with cross conversion.
            
            <seealso cref="T:Parquet.Thrift.ConvertedType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Scale">
            <summary>
            Used when this column contains decimal data.
            See the DECIMAL converted type for more details.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Field_id">
            <summary>
            When the original schema supports field ids, this will save the
            original field id in the parquet schema
            </summary>
        </member>
        <member name="T:Parquet.Thrift.SortingColumn">
            <summary>
            Wrapper struct to specify sort order
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SortingColumn.Column_idx">
            <summary>
            The column index (in this row group) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SortingColumn.Descending">
            <summary>
            If true, indicates this column is sorted in descending order. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SortingColumn.Nulls_first">
            <summary>
            If true, nulls will come before non-null values, otherwise,
            nulls go at the end.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.Statistics">
            <summary>
            Statistics per row group and per page
            All fields are optional.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.Statistics.Max">
            <summary>
            min and max value of the column, encoded in PLAIN encoding
            </summary>
        </member>
        <member name="P:Parquet.Thrift.Statistics.Null_count">
            <summary>
            count of null value in the column
            </summary>
        </member>
        <member name="P:Parquet.Thrift.Statistics.Distinct_count">
            <summary>
            count of distinct values occurring
            </summary>
        </member>
        <member name="T:Parquet.Thrift.Type">
            <summary>
            Types supported by Parquet.  These types are intended to be used in combination
            with the encodings to control the on disk storage format.
            For example INT16 is not included as a type since a good encoding of INT32
            would handle this.
            </summary>
        </member>
        <member name="T:Parquet.WriterOptions">
            <summary>
            Writer options
            </summary>
        </member>
        <member name="M:Parquet.WriterOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.WriterOptions"/> class.
            </summary>
        </member>
        <member name="P:Parquet.WriterOptions.RowGroupsSize">
            <summary>
            Gets or sets the size of the row group.
            </summary>
        </member>
        <member name="P:Parquet.WriterOptions.UseDictionaryEncoding">
            <summary>
            Gets or sets the flag whether to use dictionary encoding when writing.
            </summary>
        </member>
        <member name="P:Parquet.WriterOptions.ForceFixedByteArraysForDecimals">
            <summary>
            Gets or sets the flag whether to force decimal type encoding as fixed bytes. Hive and Impala only
            understands decimals when forced to true.
            </summary>
        </member>
    </members>
</doc>
